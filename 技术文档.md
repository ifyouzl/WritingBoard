# 🔬 WritingBoard 技术文档

## 目录

1. [实现流程详解](#实现流程详解)
2. [技术难点与解决方案](#技术难点与解决方案)
3. [代码组织与最佳实践](#代码组织与最佳实践)
4. [性能优化](#性能优化)
5. [安全性考虑](#安全性考虑)

---

## 实现流程详解

### 阶段1：项目初始化（第1天）

#### 1.1 创建项目结构

```bash
mkdir WritingBoard
cd WritingBoard
npm init -y
```

#### 1.2 安装核心依赖

```bash
# Electron 框架
npm install --save-dev electron electron-builder

# React 框架
npm install react react-dom
npm install --save-dev @types/react @types/react-dom

# TypeScript
npm install --save-dev typescript ts-loader

# Webpack
npm install --save-dev webpack webpack-cli webpack-dev-server
npm install --save-dev html-webpack-plugin css-loader style-loader
```

#### 1.3 配置文件

创建 `tsconfig.json`、`webpack.renderer.config.js`、`package.json` 等配置文件。

---

### 阶段2：主进程开发（第2天）

#### 2.1 创建主进程入口

**文件：** `src/main/main.ts`

**核心功能实现：**

```typescript
// 1. 导入必要模块
import { app, BrowserWindow, ipcMain } from 'electron';
import * as path from 'path';
import * as fs from 'fs';

// 2. 设置D盘数据路径
const customDataPath = 'D:\\WritingBoard\\Data';
app.setPath('userData', customDataPath);

// 3. 创建窗口
function createWindow() {
  mainWindow = new BrowserWindow({
    width: 400,
    height: 600,
    webPreferences: {
      nodeIntegration: false,    // 安全：禁用Node集成
      contextIsolation: true,    // 安全：启用上下文隔离
      preload: path.join(__dirname, 'preload.js')
    }
  });
}

// 4. 应用生命周期
app.whenReady().then(createWindow);
```

**关键点：**
- ✅ 使用 `app.setPath` 设置自定义数据路径
- ✅ 配置安全的 webPreferences
- ✅ 预加载脚本隔离主进程和渲染进程

#### 2.2 实现文件操作

```typescript
// 保存数据到文件
ipcMain.handle('save-data', async (event, data) => {
  try {
    const dataPath = path.join(customDataPath, 'writingboard-data.json');
    fs.writeFileSync(dataPath, JSON.stringify(data, null, 2));
    return { success: true };
  } catch (error) {
    return { success: false, error: String(error) };
  }
});

// 从文件加载数据
ipcMain.handle('load-data', async () => {
  try {
    const dataPath = path.join(customDataPath, 'writingboard-data.json');
    if (fs.existsSync(dataPath)) {
      const data = fs.readFileSync(dataPath, 'utf-8');
      return JSON.parse(data);
    }
    return { todos: [], notes: [], quickNote: '' };
  } catch (error) {
    return { todos: [], notes: [], quickNote: '' };
  }
});
```

**关键点：**
- ✅ 使用 `ipcMain.handle` 处理异步操作
- ✅ 错误处理和默认值
- ✅ JSON 格式化存储（便于调试）

#### 2.3 实现小组件窗口

```typescript
function createWidgetWindow() {
  widgetWindow = new BrowserWindow({
    width: 280,
    height: 400,
    frame: false,        // 无边框
    transparent: true,   // 透明背景
    alwaysOnTop: true,  // 始终在最前
    skipTaskbar: true   // 不显示在任务栏
  });
}

// 切换到小组件模式
ipcMain.handle('toggle-widget', async (event, show) => {
  if (show) {
    createWidgetWindow();
    mainWindow.hide();  // 隐藏主窗口
  } else {
    widgetWindow.close();
    mainWindow.show();  // 显示主窗口
  }
});
```

**关键点：**
- ✅ 无边框设计
- ✅ 窗口切换逻辑
- ✅ 保持在最前端

---

### 阶段3：预加载脚本（第2天）

#### 3.1 创建安全桥梁

**文件：** `src/main/preload.ts`

```typescript
import { contextBridge, ipcRenderer } from 'electron';

// 暴露安全的API给渲染进程
contextBridge.exposeInMainWorld('electronAPI', {
  // 数据操作
  saveData: (data: any) => ipcRenderer.invoke('save-data', data),
  loadData: () => ipcRenderer.invoke('load-data'),
  
  // 窗口操作
  toggleWidget: (show: boolean) => ipcRenderer.invoke('toggle-widget', show),
  restoreMainWindow: () => ipcRenderer.invoke('restore-main-window'),
  
  // 数据监听（小组件用）
  onDataUpdate: (callback: (data: any) => void) => {
    const subscription = (event: any, data: any) => callback(data);
    ipcRenderer.on('data-update', subscription);
    return () => ipcRenderer.removeListener('data-update', subscription);
  }
});
```

**安全性考虑：**
- ✅ 只暴露必要的API
- ✅ 使用白名单方式
- ✅ 不直接暴露 `ipcRenderer`

#### 3.2 TypeScript 类型定义

**文件：** `src/renderer/types/global.d.ts`

```typescript
interface ElectronAPI {
  saveData: (data: any) => Promise<{ success: boolean }>;
  loadData: () => Promise<any>;
  toggleWidget: (show: boolean) => Promise<{ success: boolean }>;
  restoreMainWindow: () => Promise<{ success: boolean }>;
  onDataUpdate: (callback: (data: any) => void) => () => void;
}

interface Window {
  electronAPI: ElectronAPI;
}
```

**好处：**
- ✅ TypeScript 类型检查
- ✅ 智能提示
- ✅ 编译时错误检查

---

### 阶段4：渲染进程开发（第3-4天）

#### 4.1 应用主组件

**文件：** `src/renderer/App.tsx`

**状态管理：**

```typescript
const App: React.FC = () => {
  // 状态定义
  const [activeTab, setActiveTab] = useState<'quick' | 'todos' | 'notes'>('quick');
  const [todos, setTodos] = useState<Todo[]>([]);
  const [notes, setNotes] = useState<Note[]>([]);
  const [quickNoteText, setQuickNoteText] = useState<string>('');
  
  // 初始加载
  useEffect(() => {
    loadData();
  }, []);
  
  // 自动保存
  useEffect(() => {
    if (!isInitialLoad) {
      saveData();
    }
  }, [todos, notes, quickNoteText]);
};
```

**数据流：**
```
用户操作
  ↓
setState (React)
  ↓
useEffect 检测到变化
  ↓
调用 electronAPI.saveData()
  ↓
主进程保存到文件
```

#### 4.2 快速笔记组件

**文件：** `src/renderer/components/QuickNote.tsx`

```typescript
const QuickNote: React.FC<QuickNoteProps> = ({ text, onChange }) => {
  return (
    <div className="quick-note">
      <textarea
        value={text}
        onChange={(e) => onChange(e.target.value)}
        placeholder="在这里输入..."
      />
      <div className="footer">
        <span>{text.length} 字符</span>
        <span>✓ 自动保存</span>
      </div>
    </div>
  );
};
```

**设计思路：**
- 受控组件（value + onChange）
- 实时字符计数
- 自动保存提示

#### 4.3 待办列表组件

**文件：** `src/renderer/components/TodoList.tsx`

```typescript
const TodoList: React.FC<TodoListProps> = ({ todos, onAdd, onToggle, onDelete }) => {
  const [inputValue, setInputValue] = useState('');
  
  const handleAdd = () => {
    if (inputValue.trim()) {
      onAdd(inputValue);
      setInputValue('');
    }
  };
  
  return (
    <div className="todo-list">
      {/* 输入框 */}
      <div className="todo-input">
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && handleAdd()}
        />
        <button onClick={handleAdd}>添加</button>
      </div>
      
      {/* 任务列表 */}
      {todos.map(todo => (
        <div key={todo.id} className={`todo-item ${todo.completed ? 'completed' : ''}`}>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => onToggle(todo.id)}
          />
          <span>{todo.text}</span>
          <button onClick={() => onDelete(todo.id)}>×</button>
        </div>
      ))}
    </div>
  );
};
```

**交互设计：**
- Enter 键快速添加
- 复选框切换状态
- 删除按钮

#### 4.4 便签组件

**文件：** `src/renderer/components/NotesList.tsx`

```typescript
const NotesList: React.FC<NotesListProps> = ({ notes, onAdd, onUpdate, onDelete }) => {
  const colors = ['#fff59d', '#f8bbd0', '#b3e5fc', '#c8e6c9', '#ffe0b2', '#e1bee7'];
  
  const [editingNote, setEditingNote] = useState<Note | null>(null);
  
  return (
    <div className="notes-list">
      {/* 新建按钮 */}
      <button onClick={() => setEditingNote(newNote)}>+ 新建便签</button>
      
      {/* 便签网格 */}
      <div className="notes-grid">
        {notes.map(note => (
          <div key={note.id} className="note-card" style={{ background: note.color }}>
            <h3>{note.title}</h3>
            <p>{note.content}</p>
            <button onClick={() => onDelete(note.id)}>×</button>
          </div>
        ))}
      </div>
      
      {/* 编辑对话框 */}
      {editingNote && (
        <NoteEditor
          note={editingNote}
          colors={colors}
          onSave={(title, content, color) => {
            editingNote.id ? onUpdate(...) : onAdd(...);
            setEditingNote(null);
          }}
          onCancel={() => setEditingNote(null)}
        />
      )}
    </div>
  );
};
```

**功能特点：**
- 卡片式布局
- 颜色选择
- 编辑对话框

#### 4.5 小组件组件

**文件：** `src/renderer/components/Widget.tsx`

```typescript
const Widget: React.FC<WidgetProps> = ({ todos, onToggle, onRestore }) => {
  return (
    <div className="widget">
      <div className="widget-header">
        <span>📝 待办事项</span>
        <button onClick={onRestore}>✕</button>
      </div>
      
      <div className="widget-content">
        {todos.filter(t => !t.completed).map(todo => (
          <div key={todo.id} className="widget-todo">
            <input
              type="checkbox"
              onChange={() => onToggle(todo.id)}
            />
            <span>{todo.text}</span>
          </div>
        ))}
      </div>
    </div>
  );
};
```

**设计特点：**
- 只显示未完成任务
- 紧凑布局
- 快速操作

---

### 阶段5：样式设计（第5天）

#### 5.1 全局样式

**文件：** `src/renderer/styles/global.css`

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: #f5f5f5;
  color: #333;
}

/* 滚动条美化 */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-thumb {
  background: #ccc;
  border-radius: 4px;
}
```

#### 5.2 组件样式

每个组件都有独立的 CSS 文件：
- `QuickNote.css` - 快速笔记
- `TodoList.css` - 待办列表
- `NotesList.css` - 便签
- `Widget.css` - 小组件
- `App.css` - 应用主样式

**设计原则：**
- 组件化样式
- BEM 命名规范
- 响应式设计

---

### 阶段6：构建配置（第6天）

#### 6.1 Webpack 配置

**文件：** `webpack.renderer.config.js`

```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
const path = require('path');

module.exports = {
  entry: './src/renderer/index.tsx',
  
  output: {
    path: path.join(__dirname, 'dist/renderer'),
    filename: 'bundle.js'
  },
  
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  },
  
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/renderer/index.html'
    })
  ],
  
  devServer: {
    port: 3000,
    hot: true
  }
};
```

#### 6.2 TypeScript 配置

**主进程：** `tsconfig.main.json`
```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "outDir": "./dist"
  },
  "include": ["src/main/**/*"]
}
```

**渲染进程：** `tsconfig.json`
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "esnext",
    "jsx": "react",
    "moduleResolution": "node",
    "strict": true
  },
  "include": ["src/renderer/**/*"]
}
```

---

### 阶段7：打包发布（第7天）

#### 7.1 Electron Builder 配置

**package.json:**
```json
{
  "build": {
    "appId": "com.writingboard.app",
    "productName": "WritingBoard",
    "directories": {
      "output": "D:\\WritingBoard\\Release"
    },
    "files": [
      "dist/**/*",
      "package.json"
    ],
    "win": {
      "target": ["nsis", "portable"]
    },
    "nsis": {
      "oneClick": false,
      "allowToChangeInstallationDirectory": true
    }
  }
}
```

#### 7.2 打包脚本

**文件：** `D盘打包.bat`

```batch
@echo off
cd /d "%~dp0"

echo [1/7] 设置环境变量...
set ELECTRON_BUILDER_CACHE=D:\WritingBoard\BuildCache\electron-builder
set ELECTRON_CACHE=D:\WritingBoard\BuildCache\electron

echo [2/7] 创建目录...
if not exist "D:\WritingBoard\Data" mkdir "D:\WritingBoard\Data"

echo [3/7] 停止进程...
taskkill /F /IM WritingBoard.exe 2>nul

echo [4/7] 清理旧文件...
if exist "dist" rmdir /S /Q "dist"

echo [5/7] 编译...
call npm run build

echo [6/7] 打包...
call npm run package

echo [7/7] 完成！
explorer "D:\WritingBoard\Release"
pause
```

---

## 技术难点与解决方案

### 难点1：Electron 安全性

**问题：** 渲染进程不能直接访问 Node.js API

**解决：**
- 启用 `contextIsolation`
- 禁用 `nodeIntegration`
- 使用 preload 脚本作为桥梁

### 难点2：数据持久化

**问题：** 如何可靠地保存数据

**解决：**
- 使用 JSON 文件存储
- 自动保存机制
- 错误处理和默认值

### 难点3：窗口管理

**问题：** 主窗口和小组件窗口切换

**解决：**
- 使用 `hide()`/`show()` 而不是 `close()`
- 数据同步通过 IPC 通信
- 小组件监听数据更新

### 难点4：打包路径

**问题：** 批处理脚本在错误目录运行

**解决：**
- 使用 `cd /d "%~dp0"` 切换到脚本目录
- 统一使用 D盘路径
- 环境变量设置

---

## 代码组织与最佳实践

### 1. 文件组织

```
按功能分层：
- main/ - 主进程
- renderer/ - 渲染进程
  - components/ - React 组件
  - styles/ - 样式文件
  - types/ - 类型定义
```

### 2. 命名规范

- **组件：** PascalCase（QuickNote.tsx）
- **函数：** camelCase（saveData）
- **常量：** UPPER_SNAKE_CASE（MAX_LENGTH）
- **CSS类：** kebab-case（.quick-note）

### 3. TypeScript 使用

```typescript
// 定义接口
interface Todo {
  id: string;
  text: string;
  completed: boolean;
  createdAt: number;
}

// 类型注解
const addTodo = (text: string): void => {
  // ...
}

// 泛型使用
const [todos, setTodos] = useState<Todo[]>([]);
```

---

## 性能优化

### 1. React 优化

```typescript
// 使用 React.memo 避免不必要的重渲染
const TodoItem = React.memo(({ todo, onToggle, onDelete }) => {
  return (
    <div className="todo-item">
      {/* ... */}
    </div>
  );
});
```

### 2. 数据保存节流

```typescript
// 避免频繁保存
const debouncedSave = debounce(() => {
  saveData();
}, 500);

useEffect(() => {
  debouncedSave();
}, [todos, notes]);
```

### 3. Webpack 优化

```javascript
// 生产模式压缩
mode: 'production',
optimization: {
  minimize: true
}
```

---

## 安全性考虑

### 1. 渲染进程隔离

```typescript
webPreferences: {
  nodeIntegration: false,     // 禁用 Node 集成
  contextIsolation: true,     // 启用上下文隔离
  sandbox: true               // 启用沙箱
}
```

### 2. CSP (内容安全策略)

```html
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; script-src 'self'">
```

### 3. 输入验证

```typescript
// 验证用户输入
const addTodo = (text: string) => {
  if (!text || text.trim().length === 0) {
    return; // 拒绝空输入
  }
  if (text.length > 500) {
    return; // 拒绝过长输入
  }
  // 继续处理...
};
```

---

## 总结

这个项目展示了 Electron 桌面应用开发的完整流程：

1. **架构设计** - 主进程 + 渲染进程
2. **安全通信** - 预加载脚本 + IPC
3. **UI开发** - React 组件化
4. **数据持久化** - JSON 文件存储
5. **打包发布** - Electron Builder

**适合学习者的原因：**
- ✅ 代码结构清晰
- ✅ 功能完整但不复杂
- ✅ 技术栈现代化
- ✅ 有实际应用价值

**下一步学习建议：**
1. 尝试添加新功能（如搜索、标签）
2. 学习状态管理（Redux、MobX）
3. 探索 Electron 进阶功能（系统托盘、全局快捷键）
4. 了解应用更新机制（electron-updater）

---

**最后更新：** 2025年10月

